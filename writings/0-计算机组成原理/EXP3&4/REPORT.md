<h1 style="text-align:center"><small>计算机组成原理</small><br/>实验 3: SRAM 实验<br/>实验 4: UART 串口实验<br/><big>实验报告</big></h1>
<p style="text-align:right">李祥泽<br/><small>2018011331<br/>lee_johnson@qq.com</small></p>

## 实验目的 ##

1.  熟悉 THINPad 教学计算机存储器和串行接口的配置及与总线的连接方式;
2.  掌握 THINPad 教学机内存 (RAM) 和串口 UART 的访问时序和方法;
3.  理解总线数据传输的基本原理.

## 实验内容 ##

使用教学计算机上的 FPGA 芯片, 设计内存和串口的读写逻辑, 完成以下功能:

1. 将拨码开关设置为起始地址 (记作 Addr), 地址的单位是 32 位 (即 1 个 word). 
2. 单击 RST 按键. 
3. 从 UART 串口自动读取 10 个字节的数据, 将其依次存储在 BaseRAM 以 Addr 开始的 10 个字中. 
4. 将收到的数据按原顺序自动发送给 UART 串口. 
5. 再设置拨码开关, 单击 RST 按键, 能够重复以上过程. 


## 实验过程 ##

设计了用于联合控制 BaseRAM 和 UART 串口的控制器 `MemController`. 在该控制器中有 3 个状态机, 分别控制: 1. 控制器当前的读写状态, 2. 读串口-写内存的节拍, 3. 读内存-写串口的节拍. 另外, 还有一组用来暂存数据的寄存器 `data`; 如果总线没有被设置成高阻态 (由信号 `dataHiZ` 控制), 就将从这个寄存器中取数据.  

>   从将来复用该设计的角度来说, 我认为应该设计 5 个状态机, 其中 1 个是主控, 剩下 4 个分别控制串口的读, 串口的写和内存的读, 写. 
>
>   但是, 在本实验中, 串口的读总是紧跟着内存的写, 反之亦然, 因此状态机可以简化成 3 个. 
>
>   我认为这样的简化还是有意义的, 因为同时控制多个状态机的代码实在是太复杂了 (当然更可能是我学艺不精, 没搞懂多个状态机互相交互的精髓).

在 RST 被按下时, 控制器从拨码开关 (`dip_sw`) 获取地址设定, 存入一组寄存器 `baseAddr`. 这将作为内存寻址的基址, 与主控状态机中的计数器相加后传给 BaseRAM. 同时, 所有状态机都将被复位, 所有使能信号都设置为**不使能**. 

**读串口-写内存状态机**有 7 个状态, 为 (均以 `READ_` 开头, 以转移顺序排列):

1.  `IDLE`: 空置状态, 为初始状态, 也是完成一轮操作后进入的状态. 该状态不会自动转出, 而是由主控状态机控制它转移到下面一个状态. 
2.  `STDBY`: 预备状态. 从该状态转出时, `dataHiZ` 将被拉高 (使数据总线进入高阻态). 
3.  `WAIT_UART`: 等待数据到来. 该状态只在 `uart_dataready` 为高时自动转移到下一个状态. 转出时将 `uart_rdn` 拉低以开始读取. 
4.  `READ_UART`: 从 UART 串口读数据. 从该状态转出时, 数据将被存入数据寄存器 `data`; 并且 `uart_rdn` 被拉高. 
5.  `BUBBLE`: 一个空节拍. 从该状态转出时 `dataHiZ` 拉低, 数据从寄存器进入总线. 
6.  `WAIT_RAM`: 也类似于空节拍, 确保数据总线上的数据达到 RAM 所要求的建立时间. 转出时 `ram_we_n` 拉低以开始写入. 
7.  `WRITE_RAM`: 写入内存. 转移的下一个状态是 `IDLE`. 转出时 `ram_we_n` 拉高. 

**读内存-写串口**状态机有 12 个状态, 为 (均以 `WRITE_` 开头, 以转移顺序排列, 合并了):

1.  `IDLE`: 与上一个类似. 
2.  `STDBY`: 类似, 转出时将 `dataHiZ` 拉高以准备读. 
3.  `WAIT_RAM`: 一个空节拍, 转出时将 `ram_oe_n` 拉低开始读内存. 
4.  `READ_RAM`: 读内存, 使数据从内存中进入总线. 转出时将总线数据装入 `data`, 并将 `ram_oe_n` 拉高. 
5.  `BUBBLE`: 类似的空节拍. 转出时 `dataHiZ` 拉低. 
6.  `LOAD_UART`: 仍然是空节拍, 确保数据在总线上经过足够长时间. 转出时将 `uart_wrn` 拉低开始将数据装入串口的寄存器. 
7.  `LOAD_BUB_1`, `LOAD_BUB_2`, `LOAD_BUB_3`: 将数据装入串口的空节拍. 经验主义的产物, 应该算是为了解决串口和控制器之间的时钟跨域问题而加进去的. 
8.  `WRITE_UART`: 写串口. 转出时将 `uart_wrn` 拉高, 使串口开始向外写. 
9.  `WAIT_TBRE`, `WAIT_TSRE`: 等待这两个信号拉高, 也即等待串口完成写. 完成后转 `IDLE`. 

**主控**状态机有四个状态, 为 (以 `MAIN_` 开头):

1.  `STDBY`: 初始状态. 转出时将计数器清零 (虽然之前应该已经是 0 了, 但是保险起见).
2.  `READ`: 读串口-写内存状态. 如果计数器到所需数值, 将计数器清零并转下一状态; 否则计数器加 1, 控制读串口-写内存状态机进入 `READ_STDBY` 状态开始操作. 
3.  `WRITE`: 读内存-写串口状态. 与上一个类似, 可以控制读内存-写串口状态机进入 `WRITE_STDBY` 状态. 
4.  `IDLE`: 全部完成后的空置状态. 不会自动转移, 等待复位按钮被按下. 

## 实验结果 ##

本实现通过了 ThinPAD-Cloud 自动评测. 

## 思考题 ##

### 1. 静态存储器的读和写各有什么特点?  ###

我们使用的是 *异步静态随机存取存储器*. 它无需外接时钟信号, 而是由输出使能 `OE` 和写入使能 `WE` 两个信号来控制. 

### 2. 什么是 RAM 芯片输出的高阻态? 它的作用是什么?  ###

### 3. 如果希望将 BaseRAM 和 ExtRAM 作为一个统一的 64 位存储器访问, 该如何进行?  ###

### 4. 总结教学机上 UART 串口和普通的串口芯片 8251 的异同.  ###

### 5. 如果要求将 PC 发过来的数据存入 BaseRAM 的某个单元, 然后将其读出, 加 1, 再送回 PC; 该如何操作?  ###